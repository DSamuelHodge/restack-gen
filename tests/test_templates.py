"""Tests for Jinja2 templates - golden file snapshots."""

from pathlib import Path

import pytest
from jinja2 import Environment, FileSystemLoader


@pytest.fixture
def template_env():
    """Create Jinja2 environment with templates directory."""
    template_dir = Path(__file__).parent.parent / "restack_gen" / "templates"
    return Environment(loader=FileSystemLoader(template_dir), trim_blocks=True, lstrip_blocks=True)


@pytest.fixture
def common_context():
    """Common template context for all templates."""
    return {
        "generator_version": "1.0.0",
        "timestamp": "2025-01-15T10:30:00Z",
        "project_name": "testapp",
    }


class TestFunctionTemplate:
    """Tests for function.py.j2 template."""

    def test_simple_function(self, template_env, common_context) -> None:
        """Test function template with simple parameters."""
        template = template_env.get_template("function.py.j2")
        context = {
            **common_context,
            "command": "restack g function SendEmail",
            "name": "SendEmail",
            "function_name": "send_email",
            "description": "Send an email notification",
            "params": [
                {"name": "to_address", "description": "Recipient email address"},
                {"name": "subject", "description": "Email subject line"},
                {"name": "body", "description": "Email body content"},
            ],
            "params_signature": "to_address: str, subject: str, body: str",
            "return_type": "bool",
            "return_description": "True if email sent successfully",
        }

        result = template.render(**context)

        # Verify structure
        assert "# @generated by restack-gen v1.0.0" in result
        assert "# command: restack g function SendEmail" in result
        assert '@function.defn(name="send_email")' in result
        assert "async def send_email(to_address: str, subject: str, body: str) -> bool:" in result
        assert "from testapp.common.retries import DEFAULT_RETRY" in result
        assert "raise NotImplementedError" in result

    def test_function_no_params(self, template_env, common_context) -> None:
        """Test function template with no parameters."""
        template = template_env.get_template("function.py.j2")
        context = {
            **common_context,
            "command": "restack g function GetTime",
            "name": "GetTime",
            "function_name": "get_time",
            "description": "Get current timestamp",
            "params": [],
            "params_signature": "",
            "return_type": "str",
            "return_description": "Current timestamp as ISO string",
        }

        result = template.render(**context)

        assert "async def get_time() -> str:" in result
        assert "extra={" in result  # Will have empty dict with possible whitespace

    def test_function_void_return(self, template_env, common_context) -> None:
        """Test function template with void return."""
        template = template_env.get_template("function.py.j2")
        context = {
            **common_context,
            "command": "restack g function LogEvent",
            "name": "LogEvent",
            "function_name": "log_event",
            "description": "Log an event",
            "params": [{"name": "event_name", "description": "Event name"}],
            "params_signature": "event_name: str",
            "return_type": "None",
            "return_description": "No return value",
        }

        result = template.render(**context)

        assert "-> None:" in result
        assert "pass" in result
        assert "raise NotImplementedError" not in result


class TestWorkflowTemplate:
    """Tests for workflow.py.j2 template."""

    def test_workflow_with_io(self, template_env, common_context) -> None:
        """Test workflow template with input and output models."""
        template = template_env.get_template("workflow.py.j2")
        context = {
            **common_context,
            "command": "restack g workflow EmailCampaign",
            "name": "EmailCampaign",
            "workflow_name": "EmailCampaign",
            "description": "Email campaign workflow",
            "has_input": True,
            "has_output": True,
            "input_fields": [
                {
                    "name": "campaign_id",
                    "type": "str",
                    "optional": False,
                    "description": "Campaign ID",
                },
                {
                    "name": "template_name",
                    "type": "str",
                    "optional": True,
                    "description": "Template name",
                },
            ],
            "output_fields": [
                {
                    "name": "sent_count",
                    "type": "int",
                    "optional": False,
                    "description": "Emails sent",
                },
                {
                    "name": "failed_count",
                    "type": "int",
                    "optional": False,
                    "description": "Failed emails",
                },
            ],
            "input_type": "EmailCampaignInput",
            "output_type": "EmailCampaignOutput",
            "input_description": "Campaign parameters",
            "output_description": "Campaign results",
        }

        result = template.render(**context)

        assert "class EmailCampaignInput(BaseModel):" in result
        assert "campaign_id: str  # Campaign ID" in result
        assert "template_name: str | None = None  # Template name" in result
        assert "class EmailCampaignOutput(BaseModel):" in result
        assert '@workflow.defn(name="EmailCampaign")' in result
        assert "async def run(self, input: EmailCampaignInput) -> EmailCampaignOutput:" in result
        assert "output = EmailCampaignOutput()" in result

    def test_workflow_no_io(self, template_env, common_context) -> None:
        """Test workflow template with no input/output."""
        template = template_env.get_template("workflow.py.j2")
        context = {
            **common_context,
            "command": "restack g workflow CleanupTask",
            "name": "CleanupTask",
            "workflow_name": "CleanupTask",
            "description": "Cleanup task workflow",
            "has_input": False,
            "has_output": False,
            "input_fields": [],
            "output_fields": [],
            "input_type": "None",
            "output_type": "None",
            "input_description": "No input",
            "output_description": "No output",
        }

        result = template.render(**context)

        assert "class CleanupTaskInput" not in result
        assert "class CleanupTaskOutput" not in result
        assert "async def run(self, input: None) -> None:" in result


class TestAgentTemplate:
    """Tests for agent.py.j2 template."""

    def test_agent_with_events(self, template_env, common_context) -> None:
        """Test agent template with events and state."""
        template = template_env.get_template("agent.py.j2")
        context = {
            **common_context,
            "command": "restack g agent Onboarding",
            "name": "Onboarding",
            "agent_name": "Onboarding",
            "event_enum_name": "OnboardingEvent",
            "description": "User onboarding agent",
            "events": [
                {
                    "constant": "USER_REGISTERED",
                    "value": "user_registered",
                    "description": "User completed registration",
                    "handler_name": "user_registered",
                    "test_name": "user_registered",
                },
                {
                    "constant": "EMAIL_VERIFIED",
                    "value": "email_verified",
                    "description": "Email verification completed",
                    "handler_name": "email_verified",
                    "test_name": "email_verified",
                },
            ],
            "state_fields": [
                {"name": "user_id", "type": "str", "optional": False, "description": "User ID"},
                {
                    "name": "email_verified",
                    "type": "bool",
                    "optional": False,
                    "description": "Email verified flag",
                },
                {
                    "name": "onboarding_step",
                    "type": "int",
                    "optional": True,
                    "description": "Current step",
                },
            ],
        }

        result = template.render(**context)

        assert "class OnboardingEvent(str, Enum):" in result
        assert 'USER_REGISTERED = "user_registered"' in result
        assert 'EMAIL_VERIFIED = "email_verified"' in result
        assert "class OnboardingState(BaseModel):" in result
        assert "user_id: str  # User ID" in result
        assert "onboarding_step: int | None = None  # Current step" in result
        assert '@workflow.defn(name="Onboarding")' in result
        assert "async def run(self, initial_state: OnboardingState) -> None:" in result
        assert "@workflow.signal" in result
        assert "async def handle_event(self, event: OnboardingEvent" in result
        assert "case OnboardingEvent.USER_REGISTERED:" in result
        assert "await self._handle_user_registered(payload)" in result
        assert "async def _handle_user_registered(self, payload: dict | None) -> None:" in result


class TestPipelineTemplate:
    """Tests for pipeline_orchestrator.py.j2 template."""

    def test_pipeline_with_loops(self, template_env, common_context) -> None:
        """Test pipeline template with sequential and loop steps."""
        template = template_env.get_template("pipeline_orchestrator.py.j2")
        context = {
            **common_context,
            "command": "restack g pipeline BlogPipeline",
            "name": "BlogPipeline",
            "pipeline_name": "BlogPipeline",
            "description": "Blog content generation pipeline",
            "pipeline_diagram": "IDEATE → RESEARCH ⇄ PLAN → DRAFT",
            "task_queue": "default",
            "token_fields": [
                {"name": "topic", "type": "str", "optional": False, "description": "Blog topic"},
                {"name": "draft", "type": "str", "optional": True, "description": "Draft content"},
            ],
            "steps": [
                {
                    "type": "sequential",
                    "name": "IDEATE",
                    "function_name": "ideate",
                    "workflow_class": "IdeateWorkflow",
                    "output_field": "ideas",
                },
                {
                    "type": "loop",
                    "name": "RESEARCH ⇄ PLAN",
                    "function_name": "research_plan",
                    "loop_key": "research_plan",
                    "node_a": "RESEARCH",
                    "node_b": "PLAN",
                    "node_a_function": "research",
                    "node_b_function": "plan",
                },
                {
                    "type": "sequential",
                    "name": "DRAFT",
                    "function_name": "draft",
                    "workflow_class": "DraftWorkflow",
                    "output_field": "draft",
                },
            ],
        }

        result = template.render(**context)

        assert "class BlogPipelineToken(BaseModel):" in result
        assert "topic: str  # Blog topic" in result
        assert '@workflow.defn(name="BlogPipeline")' in result
        assert "async def run(self, input: BlogPipelineToken) -> BlogPipelineToken:" in result
        assert "# Step: IDEATE" in result
        assert "token = await self._step_ideate(token)" in result
        assert "# Loop: RESEARCH ⇄ PLAN" in result
        assert "token = await self._loop_research_plan(token)" in result
        assert "async def _loop_research_plan(self, token: BlogPipelineToken)" in result
        assert "max_iterations = settings.pipeline.loops.research_plan.max" in result
        assert (
            "while iteration < max_iterations and await self._should_continue_research_plan"
            in result
        )


class TestServiceTemplate:
    """Tests for service.py.j2 template."""

    def test_service_with_resources(self, template_env, common_context) -> None:
        """Test service template with agents, workflows, and functions."""
        template = template_env.get_template("service.py.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
            "task_queue": "default",
            "agents": [
                {"module": "onboarding", "class_name": "Onboarding"},
            ],
            "workflows": [
                {"module": "email_campaign", "class_name": "EmailCampaign"},
                {"module": "blog_pipeline", "class_name": "BlogPipeline"},
            ],
            "functions": [
                {"module": "send_email", "name": "send_email"},
                {"module": "log_event", "name": "log_event"},
            ],
        }

        result = template.render(**context)

        assert "from testapp.agents.onboarding import Onboarding" in result
        assert "from testapp.workflows.email_campaign import EmailCampaign" in result
        assert "from testapp.functions.send_email import send_email" in result
        assert "await client.start_service(" in result
        assert "workflows=[" in result
        assert "Onboarding," in result
        assert "EmailCampaign," in result
        assert "functions=[" in result
        assert "send_email," in result
        assert 'task_queue="default"' in result


class TestCommonModuleTemplates:
    """Tests for common module templates."""

    def test_retries_template(self, template_env, common_context) -> None:
        """Test retries.py.j2 template."""
        template = template_env.get_template("retries.py.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
        }

        result = template.render(**context)

        assert "DEFAULT_RETRY = RetryPolicy(" in result
        assert "AGGRESSIVE_RETRY = RetryPolicy(" in result
        assert "NO_RETRY = RetryPolicy(" in result
        assert "LONG_RETRY = RetryPolicy(" in result

    def test_settings_template(self, template_env, common_context) -> None:
        """Test settings.py.j2 template."""
        template = template_env.get_template("settings.py.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
            "task_queue": "testapp-queue",
            "env_prefix": "TESTAPP",
        }

        result = template.render(**context)

        assert "class Settings(SettingsBase):" in result
        assert "restack_engine_id: str" in result
        assert 'default="testapp-queue"' in result
        assert 'env_prefix = "TESTAPP_"' in result
        assert "settings = Settings.from_yaml(_config_file)" in result

    def test_compat_template(self, template_env, common_context) -> None:
        """Test compat.py.j2 template."""
        template = template_env.get_template("compat.py.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
        }

        result = template.render(**context)

        assert "PYDANTIC_V2" in result
        assert "class BaseModel" in result
        assert "class SettingsBase" in result
        assert "def from_yaml(cls, path):" in result


class TestClientTemplates:
    """Tests for client templates."""

    def test_client_schedule_agent(self, template_env, common_context) -> None:
        """Test client_schedule_agent.py.j2 template."""
        template = template_env.get_template("client_schedule_agent.py.j2")
        context = {
            **common_context,
            "command": "restack g agent Onboarding",
            "agent_name": "Onboarding",
            "agent_module": "onboarding",
            "agent_id": "onboarding-user-123",
            "task_queue": "default",
        }

        result = template.render(**context)

        assert "from testapp.agents.onboarding import Onboarding, OnboardingState" in result
        assert "initial_state = OnboardingState(" in result
        assert 'workflow_id = "onboarding-user-123"' in result
        assert "await client.schedule_workflow(" in result

    def test_client_run_workflow(self, template_env, common_context) -> None:
        """Test client_run_workflow.py.j2 template."""
        template = template_env.get_template("client_run_workflow.py.j2")
        context = {
            **common_context,
            "command": "restack g workflow EmailCampaign",
            "workflow_name": "EmailCampaign",
            "workflow_module": "email_campaign",
            "workflow_id": "email-campaign-202501",
            "task_queue": "default",
            "has_input": True,
        }

        result = template.render(**context)

        assert (
            "from testapp.workflows.email_campaign import EmailCampaign, EmailCampaignInput"
            in result
        )
        assert "input_data = EmailCampaignInput(" in result
        assert 'workflow_id = "email-campaign-202501"' in result
        assert "result = await client.get_workflow_result(" in result


class TestProjectBoilerplateTemplates:
    """Tests for project boilerplate templates."""

    def test_pyproject_toml(self, template_env, common_context) -> None:
        """Test pyproject.toml.j2 template."""
        template = template_env.get_template("pyproject.toml.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
            "version": "0.1.0",
            "description": "Test application",
        }

        result = template.render(**context)

        assert "[project]" in result
        assert 'name = "testapp"' in result
        assert 'version = "0.1.0"' in result
        assert 'description = "Test application"' in result
        assert "restack-ai>=0.2.0" in result
        assert "[tool.pytest.ini_options]" in result

    def test_makefile(self, template_env, common_context) -> None:
        """Test Makefile.j2 template."""
        template = template_env.get_template("Makefile.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
        }

        result = template.render(**context)

        assert "help:" in result
        assert "fmt:" in result
        assert "test:" in result
        assert "run:" in result
        assert "python server/service.py" in result

    def test_settings_yaml(self, template_env, common_context) -> None:
        """Test settings.yaml.j2 template."""
        template = template_env.get_template("settings.yaml.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
            "task_queue": "testapp-queue",
        }

        result = template.render(**context)

        assert 'task_queue: "testapp-queue"' in result
        assert "default_timeout: 300" in result
        assert "pipeline:" in result
        assert "loops:" in result

    def test_env_example(self, template_env, common_context):
        """Test .env.example.j2 template."""
        template = template_env.get_template(".env.example.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
            "task_queue": "testapp-queue",
            "env_prefix": "TESTAPP",
        }

        result = template.render(**context)

        assert "TESTAPP_RESTACK_ENGINE_ID=" in result
        assert "TESTAPP_TASK_QUEUE=testapp-queue" in result
        assert "TESTAPP_PIPELINE__LOOPS__MY_LOOP__MAX=" in result

    def test_readme(self, template_env, common_context) -> None:
        """Test README.md.j2 template."""
        template = template_env.get_template("README.md.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
            "description": "Test application for Restack",
        }

        result = template.render(**context)

        assert "# testapp" in result
        assert "Test application for Restack" in result
        assert "## Setup" in result
        assert "make install-dev" in result
        assert "restack-gen v1.0.0" in result

    def test_gitignore(self, template_env, common_context) -> None:
        """Test .gitignore.j2 template."""
        template = template_env.get_template(".gitignore.j2")
        context = {
            **common_context,
            "command": "restack new testapp",
        }

        result = template.render(**context)

        assert "*.pyc" in result
        assert "__pycache__/" in result
        assert ".venv/" in result
        assert ".pytest_cache/" in result
        assert ".env" in result


class TestTemplateTestTemplates:
    """Tests for test templates."""

    def test_test_agent(self, template_env, common_context) -> None:
        """Test test_agent.py.j2 template."""
        template = template_env.get_template("test_agent.py.j2")
        context = {
            **common_context,
            "command": "restack g agent Onboarding",
            "agent_name": "Onboarding",
            "agent_module": "onboarding",
            "agent_test_name": "onboarding",
            "event_enum_name": "OnboardingEvent",
            "events": [
                {
                    "value": "user_registered",
                    "test_name": "user_registered",
                },
            ],
        }

        result = template.render(**context)

        assert "from testapp.agents.onboarding import Onboarding" in result
        assert "async def test_onboarding_initialization():" in result
        assert "async def test_onboarding_handle_events():" in result
        assert "async def test_onboarding_user_registered():" in result

    def test_test_workflow(self, template_env, common_context) -> None:
        """Test test_workflow.py.j2 template."""
        template = template_env.get_template("test_workflow.py.j2")
        context = {
            **common_context,
            "command": "restack g workflow EmailCampaign",
            "workflow_name": "EmailCampaign",
            "workflow_module": "email_campaign",
            "workflow_test_name": "email_campaign",
            "has_input": True,
            "has_output": True,
        }

        result = template.render(**context)

        assert "from testapp.workflows.email_campaign import EmailCampaign" in result
        assert "async def test_email_campaign_success():" in result
        assert "input_data = EmailCampaignInput(" in result
        assert "assert isinstance(result, EmailCampaignOutput)" in result

    def test_test_function(self, template_env, common_context) -> None:
        """Test test_function.py.j2 template."""
        template = template_env.get_template("test_function.py.j2")
        context = {
            **common_context,
            "command": "restack g function send_email",
            "function_name": "send_email",
            "function_module": "send_email",
            "function_test_name": "send_email",
            "params": [
                {"name": "to_address"},
                {"name": "subject"},
            ],
            "params_call": "to_address, subject",
            "return_type": "bool",
        }

        result = template.render(**context)

        assert "from testapp.functions.send_email import send_email" in result
        assert "async def test_send_email_success():" in result
        assert "to_address = None" in result
        assert "result = await send_email(to_address, subject)" in result
