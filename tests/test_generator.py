"""Tests for resource generation (agents, workflows, functions)."""

import pytest
from pathlib import Path

from restack_gen.generator import (
    GenerationError,
    generate_agent,
    generate_function,
    generate_pipeline,
    generate_workflow,
    find_project_root,
    get_project_name,
    to_pascal_case,
    to_snake_case,
    validate_name,
)
from restack_gen.project import create_new_project


class TestNameConversion:
    """Test name conversion utilities."""

    def test_to_snake_case(self):
        assert to_snake_case("MyAgent") == "my_agent"
        assert to_snake_case("EmailWorkflow") == "email_workflow"
        assert to_snake_case("SendEmail") == "send_email"
        assert to_snake_case("lowercase") == "lowercase"

    def test_to_pascal_case(self):
        assert to_pascal_case("my_agent") == "MyAgent"
        assert to_pascal_case("email_workflow") == "EmailWorkflow"
        assert to_pascal_case("send_email") == "SendEmail"
        assert to_pascal_case("single") == "Single"


class TestNameValidation:
    """Test resource name validation."""

    def test_valid_names(self):
        valid_names = [
            "my_agent",
            "MyAgent",
            "workflow",
            "send_email",
            "_private",
        ]
        for name in valid_names:
            is_valid, error = validate_name(name)
            assert is_valid, f"{name} should be valid: {error}"

    def test_empty_name(self):
        is_valid, error = validate_name("")
        assert not is_valid
        assert "empty" in error.lower()

    def test_invalid_characters(self):
        invalid_names = ["my-agent", "my.workflow", "my agent", "my@function"]
        for name in invalid_names:
            is_valid, error = validate_name(name)
            assert not is_valid, f"{name} should be invalid"


class TestAgentGeneration:
    """Test agent generation."""

    @pytest.fixture
    def test_project(self, tmp_path):
        """Create a test project."""
        project_path = tmp_path / "testproject"
        create_new_project("testproject", parent_dir=tmp_path, force=False)
        return project_path

    def test_generate_agent_creates_files(self, test_project, monkeypatch):
        """Test that agent generation creates all expected files."""
        monkeypatch.chdir(test_project)

        files = generate_agent("researcher")

        assert files["agent"].exists()
        assert files["test"].exists()
        assert files["client"].exists()

        # Check file contains expected content
        agent_content = files["agent"].read_text()
        assert "class ResearcherAgent:" in agent_content
        assert "@generated by restack-gen" in agent_content
        assert "ResearcherAgentEvent" in agent_content

    def test_generate_agent_updates_service(self, test_project, monkeypatch):
        """Test that agent generation updates service.py."""
        monkeypatch.chdir(test_project)

        generate_agent("data")

        service_file = test_project / "server" / "service.py"
        service_content = service_file.read_text()

        # Check import added
        assert "from testproject.agents.data import DataAgent" in service_content
        # Check registration added
        assert "DataAgent," in service_content
        assert "workflows=[" in service_content

    def test_generate_agent_idempotency(self, test_project, monkeypatch):
        """Test that generating same agent twice fails without --force."""
        monkeypatch.chdir(test_project)

        generate_agent("analyzer")

        with pytest.raises(GenerationError, match="already exists"):
            generate_agent("analyzer")

    def test_generate_agent_force_overwrites(self, test_project, monkeypatch):
        """Test that --force flag allows overwriting."""
        monkeypatch.chdir(test_project)

        files1 = generate_agent("processor")
        files2 = generate_agent("processor", force=True)

        assert files1["agent"] == files2["agent"]
        assert files2["agent"].exists()

    def test_generate_agent_no_duplicates_in_service(self, test_project, monkeypatch):
        """Test that service.py doesn't get duplicate entries."""
        monkeypatch.chdir(test_project)

        generate_agent("cleaner")
        generate_agent("cleaner", force=True)

        service_file = test_project / "server" / "service.py"
        service_content = service_file.read_text()

        # Should only appear once
        assert service_content.count("DataAgent") == 0  # Not generated yet
        assert service_content.count("CleanerAgent,") == 1
        assert service_content.count("from testproject.agents.cleaner import CleanerAgent") == 1


class TestWorkflowGeneration:
    """Test workflow generation."""

    @pytest.fixture
    def test_project(self, tmp_path):
        """Create a test project."""
        project_path = tmp_path / "testproject"
        create_new_project("testproject", parent_dir=tmp_path, force=False)
        return project_path

    def test_generate_workflow_creates_files(self, test_project, monkeypatch):
        """Test that workflow generation creates all expected files."""
        monkeypatch.chdir(test_project)

        files = generate_workflow("email")

        assert files["workflow"].exists()
        assert files["test"].exists()
        assert files["client"].exists()

        # Check file contains expected content
        workflow_content = files["workflow"].read_text()
        assert "class EmailWorkflow:" in workflow_content
        assert "@generated by restack-gen" in workflow_content

    def test_generate_workflow_updates_service(self, test_project, monkeypatch):
        """Test that workflow generation updates service.py."""
        monkeypatch.chdir(test_project)

        generate_workflow("notification")

        service_file = test_project / "server" / "service.py"
        service_content = service_file.read_text()

        # Check import added
        assert (
            "from testproject.workflows.notification import NotificationWorkflow" in service_content
        )
        # Check registration added
        assert "NotificationWorkflow," in service_content


class TestFunctionGeneration:
    """Test function generation."""

    @pytest.fixture
    def test_project(self, tmp_path):
        """Create a test project."""
        project_path = tmp_path / "testproject"
        create_new_project("testproject", parent_dir=tmp_path, force=False)
        return project_path

    def test_generate_function_creates_files(self, test_project, monkeypatch):
        """Test that function generation creates all expected files."""
        monkeypatch.chdir(test_project)

        files = generate_function("send_email")

        assert files["function"].exists()
        assert files["test"].exists()
        assert "client" not in files  # Functions don't have client scripts

        # Check file contains expected content
        function_content = files["function"].read_text()
        assert "def send_email(" in function_content
        assert "@generated by restack-gen" in function_content

    def test_generate_function_updates_service(self, test_project, monkeypatch):
        """Test that function generation updates service.py."""
        monkeypatch.chdir(test_project)

        generate_function("transform_data")

        service_file = test_project / "server" / "service.py"
        service_content = service_file.read_text()

        # Check import added
        assert "from testproject.functions.transform_data import transform_data" in service_content
        # Check registration added
        assert "transform_data," in service_content
        assert "functions=[" in service_content


class TestMixedGeneration:
    """Test generating multiple resource types together."""

    @pytest.fixture
    def test_project(self, tmp_path):
        """Create a test project."""
        project_path = tmp_path / "testproject"
        create_new_project("testproject", parent_dir=tmp_path, force=False)
        return project_path

    def test_generate_all_types(self, test_project, monkeypatch):
        """Test generating agent, workflow, and function together."""
        monkeypatch.chdir(test_project)

        generate_agent("data")
        generate_workflow("process")
        generate_function("transform")

        service_file = test_project / "server" / "service.py"
        service_content = service_file.read_text()

        # Check all imports present
        assert "from testproject.agents.data import DataAgent" in service_content
        assert "from testproject.workflows.process import ProcessWorkflow" in service_content
        assert "from testproject.functions.transform import transform" in service_content

        # Check all registrations present
        assert "workflows=[" in service_content
        assert "DataAgent," in service_content
        assert "ProcessWorkflow," in service_content
        assert "functions=[" in service_content
        assert "transform," in service_content

    def test_service_file_structure(self, test_project, monkeypatch):
        """Test that service.py maintains correct structure."""
        monkeypatch.chdir(test_project)

        generate_function("first_func")
        generate_workflow("first_work")
        generate_agent("first_agent")

        service_file = test_project / "server" / "service.py"
        service_content = service_file.read_text()

        # Imports should be grouped by type
        func_import_pos = service_content.find("# Functions")
        work_import_pos = service_content.find("# Workflows")
        agent_import_pos = service_content.find("# Agents")

        # Check section order (may vary based on generation order)
        assert func_import_pos > 0
        assert work_import_pos > 0
        assert agent_import_pos > 0


class TestProjectContext:
    """Test project context utilities."""

    def test_find_project_root_from_subdirectory(self, tmp_path):
        """Test finding project root from subdirectory."""
        project_path = tmp_path / "myproject"
        create_new_project("myproject", parent_dir=tmp_path, force=False)

        # Create subdirectory and check from there
        subdir = project_path / "src" / "myproject"
        import os

        os.chdir(subdir)

        root = find_project_root()
        assert root == project_path

    def test_get_project_name(self, tmp_path):
        """Test extracting project name from pyproject.toml."""
        project_path = tmp_path / "testapp"
        create_new_project("testapp", parent_dir=tmp_path, force=False)

        name = get_project_name(project_path)
        assert name == "testapp"

    def test_generate_outside_project_fails(self, tmp_path, monkeypatch):
        """Test that generation fails outside a project."""
        monkeypatch.chdir(tmp_path)

        with pytest.raises(GenerationError, match="Not in a restack-gen project"):
            generate_agent("test")


class TestPipelineGeneration:
    """Tests for pipeline generation from operator expressions."""

    @pytest.fixture
    def test_project(self, tmp_path, monkeypatch):
        """Create a test project and chdir for pipeline generation."""
        project_path = tmp_path / "testproject"
        create_new_project("testproject", parent_dir=tmp_path, force=False)
        monkeypatch.chdir(project_path)
        return project_path

    def test_generate_pipeline_creates_files(self, test_project):
        """Test that generate_pipeline creates workflow and test files."""
        # First create some resources to reference
        generate_agent("DataFetcher", force=True)
        generate_agent("DataProcessor", force=True)
        
        # Generate pipeline
        files = generate_pipeline("DataPipeline", "DataFetcher → DataProcessor", force=True)

        assert "workflow" in files
        assert "test" in files
        assert files["workflow"].exists()
        assert files["test"].exists()
        assert files["workflow"].name == "data_pipeline_workflow.py"
        assert files["test"].name == "test_data_pipeline_workflow.py"

    def test_generate_pipeline_with_parallel(self, test_project):
        """Test pipeline generation with parallel operator."""
        # Create resources
        generate_agent("Fetch1", force=True)
        generate_agent("Fetch2", force=True)
        generate_agent("Process", force=True)
        
        files = generate_pipeline("ParallelPipeline", "Fetch1 ⇄ Fetch2 → Process", force=True)
        
        content = files["workflow"].read_text()
        assert "asyncio.gather" in content
        assert "fetch1_activity" in content
        assert "fetch2_activity" in content
        assert "process_activity" in content

    def test_generate_pipeline_with_conditional(self, test_project):
        """Test pipeline generation with conditional operator."""
        # Create resources
        generate_agent("Handler1", force=True)
        generate_agent("Handler2", force=True)
        
        files = generate_pipeline("ConditionalPipeline", "needs_processing →? (Handler1, Handler2)", force=True)
        
        content = files["workflow"].read_text()
        assert "if result.get('needs_processing'):" in content
        assert "handler1_activity" in content
        assert "handler2_activity" in content

    def test_generate_pipeline_updates_service(self, test_project):
        """Test that pipeline generation updates service.py."""
        # Create resources
        generate_agent("Source", force=True)
        generate_agent("Sink", force=True)
        
        generate_pipeline("SimplePipeline", "Source → Sink", force=True)

        service_file = test_project / "server" / "service.py"
        content = service_file.read_text()
        
        assert "from testproject.workflows.simple_pipeline_workflow import SimplePipelineWorkflow" in content
        assert "SimplePipelineWorkflow," in content

    def test_generate_pipeline_force_overwrites(self, test_project):
        """Test that force flag overwrites existing pipeline."""
        # Create resources
        generate_agent("Step1", force=True)
        generate_agent("Step2", force=True)
        
        # Generate first time
        files1 = generate_pipeline("TestPipeline", "Step1 → Step2", force=True)
        content1 = files1["workflow"].read_text()

        # Generate again with force
        files2 = generate_pipeline("TestPipeline", "Step1 → Step2", force=True)
        content2 = files2["workflow"].read_text()

        assert files1["workflow"] == files2["workflow"]
        assert content1 == content2

    def test_generate_pipeline_invalid_expression(self, test_project):
        """Test that invalid operator expression raises error."""
        with pytest.raises(GenerationError, match="Failed to parse operator expression"):
            generate_pipeline("BadPipeline", "A → → B", force=True)

    def test_generate_pipeline_has_generated_marker(self, test_project):
        """Test that generated pipeline has the @generated marker."""
        # Create resources
        generate_agent("Start", force=True)
        generate_agent("End", force=True)
        
        files = generate_pipeline("MarkerPipeline", "Start → End", force=True)
        content = files["workflow"].read_text()
        
        assert "# @generated by restack-gen" in content

    def test_generate_pipeline_generates_imports(self, test_project):
        """Test that pipeline generates correct imports."""
        # Create different resource types
        generate_agent("MyAgent", force=True)
        generate_workflow("MyWorkflow", force=True)
        generate_function("my_function", force=True)
        
        files = generate_pipeline(
            "MixedPipeline", 
            "MyAgent → MyWorkflow → MyFunction",
            force=True
        )
        content = files["workflow"].read_text()
        
        assert "from agents.my_agent import my_agent_activity" in content
        assert "from workflows.my_workflow_workflow import my_workflow_activity" in content
        assert "from functions.my_function import my_function_activity" in content

    def test_generate_pipeline_complex_expression(self, test_project):
        """Test pipeline with complex nested expression."""
        # Create resources
        for name in ["A", "B", "C", "D", "E"]:
            generate_agent(name, force=True)
        
        files = generate_pipeline(
            "ComplexPipeline",
            "A → (B ⇄ C) → (D ⇄ E)",
            force=True
        )
        
        content = files["workflow"].read_text()
        assert "a_activity" in content
        assert "asyncio.gather" in content
        assert "b_activity" in content
        assert "c_activity" in content
        assert "d_activity" in content
        assert "e_activity" in content
