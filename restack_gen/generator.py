"""Resource generation utilities for agents, workflows, and functions."""

import re
from pathlib import Path

from restack_gen.ast_service import update_service_file
from restack_gen.codegen import generate_pipeline_code
from restack_gen.renderer import render_template


class GenerationError(Exception):
    """Raised when resource generation fails."""


GENERATED_MARKER = "# @generated by restack-gen"


def to_snake_case(name: str) -> str:
    """Convert PascalCase or camelCase to snake_case.

    Args:
        name: Input name

    Returns:
        snake_case version
    """
    # Insert underscore before uppercase letters
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    # Insert underscore before uppercase letters preceded by lowercase
    s2 = re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1)
    return s2.lower()


def to_pascal_case(name: str) -> str:
    """Convert snake_case to PascalCase.

    Args:
        name: Input name in snake_case

    Returns:
        PascalCase version
    """
    parts = name.split("_")
    return "".join(word.capitalize() for word in parts)


def validate_name(name: str) -> tuple[bool, str | None]:
    """Validate resource name.

    Args:
        name: Resource name to validate

    Returns:
        Tuple of (is_valid, error_message)
    """
    if not name:
        return False, "Name cannot be empty"

    # Check for valid identifier characters
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_]*$", name):
        return (
            False,
            "Name must start with letter/underscore and contain only alphanumeric characters and underscores",
        )

    return True, None


def find_project_root() -> Path | None:
    """Find the project root by looking for pyproject.toml.

    Returns:
        Path to project root, or None if not found
    """
    current = Path.cwd()
    for parent in [current] + list(current.parents):
        if (parent / "pyproject.toml").exists():
            return parent
    return None


def get_project_name(project_root: Path) -> str:
    """Extract project name from pyproject.toml.

    Args:
        project_root: Path to project root

    Returns:
        Project name

    Raises:
        GenerationError: If project name cannot be determined
    """
    pyproject = project_root / "pyproject.toml"
    if not pyproject.exists():
        raise GenerationError("pyproject.toml not found")

    with open(pyproject, encoding="utf-8") as f:
        for line in f:
            if line.strip().startswith("name = "):
                # Extract name from 'name = "myproject"'
                name = line.split("=")[1].strip().strip('"').strip("'")
                return name

    raise GenerationError("Could not find project name in pyproject.toml")


def check_file_exists(file_path: Path, force: bool = False) -> None:
    """Check if file exists and handle according to force flag.

    Args:
        file_path: Path to check
        force: If True, allow overwriting

    Raises:
        GenerationError: If file exists and cannot be overwritten
    """
    if not file_path.exists():
        return

    # Check if file has generated marker
    with open(file_path, encoding="utf-8") as f:
        first_line = f.readline()

    if GENERATED_MARKER in first_line:
        if not force:
            raise GenerationError(
                f"File {file_path} already exists (generated). Use --force to overwrite."
            )
    else:
        raise GenerationError(
            f"File {file_path} exists but was not generated by restack-gen. "
            "Will not overwrite to preserve manual changes."
        )


def write_file(file_path: Path, content: str) -> None:
    """Write content to file, creating directories if needed.

    Args:
        file_path: Path to write to
        content: Content to write
    """
    file_path.parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)


def generate_agent(
    name: str,
    force: bool = False,
    event_type: str = "dict",
    state_type: str = "dict",
) -> dict[str, Path]:
    """Generate an agent with test and client files.

    Args:
        name: Agent name (will be converted to PascalCase for class name)
        force: If True, overwrite existing generated files
        event_type: Type for agent events
        state_type: Type for agent state

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid agent name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert name formats - ensure PascalCase
    if "_" in name:
        # snake_case input
        class_name = to_pascal_case(name) + "Agent"
        module_name = name
    else:
        # Assume PascalCase input
        class_name = name if name.endswith("Agent") else name + "Agent"
        # Ensure first letter is uppercase for PascalCase
        class_name = class_name[0].upper() + class_name[1:]
        # Extract base name without "Agent" suffix for module
        base_name = class_name.replace("Agent", "")
        module_name = to_snake_case(base_name)

    # Define file paths
    agent_file = project_root / "src" / project_name / "agents" / f"{module_name}.py"
    test_file = project_root / "tests" / f"test_{module_name}_agent.py"
    client_file = project_root / "client" / f"schedule_{module_name}.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(agent_file, force)
    check_file_exists(test_file, force)
    check_file_exists(client_file, force)

    # Prepare context
    context = {
        "project_name": project_name,
        "agent_name": class_name,
        "name": class_name,  # For template compatibility
        "event_enum_name": f"{class_name}Event",
        "module_name": module_name,
        "event_type": event_type,
        "state_type": state_type,
        "events": [],  # Empty list for now, user can add events
        "state_fields": [],  # Empty list for now, user can add state fields
    }

    # Generate agent file
    agent_content = render_template("agent.py.j2", context)
    write_file(agent_file, agent_content)

    # Generate test file
    test_content = render_template("test_agent.py.j2", context)
    write_file(test_file, test_content)

    # Generate client file
    client_content = render_template("client_schedule_agent.py.j2", context)
    write_file(client_file, client_content)

    # Update service.py
    update_service_file(service_file, "agent", module_name, class_name)

    return {
        "agent": agent_file,
        "test": test_file,
        "client": client_file,
    }


def generate_workflow(
    name: str,
    force: bool = False,
    input_type: str = "dict",
    output_type: str = "dict",
) -> dict[str, Path]:
    """Generate a workflow with test and client files.

    Args:
        name: Workflow name (will be converted to PascalCase for class name)
        force: If True, overwrite existing generated files
        input_type: Type for workflow input
        output_type: Type for workflow output

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid workflow name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert name formats - ensure PascalCase
    if "_" in name:
        # snake_case input
        class_name = to_pascal_case(name) + "Workflow"
        module_name = name
    else:
        # Assume PascalCase input
        class_name = name if name.endswith("Workflow") else name + "Workflow"
        # Ensure first letter is uppercase for PascalCase
        class_name = class_name[0].upper() + class_name[1:]
        # Extract base name without "Workflow" suffix for module
        base_name = class_name.replace("Workflow", "")
        module_name = to_snake_case(base_name)

    # Define file paths
    workflow_file = project_root / "src" / project_name / "workflows" / f"{module_name}.py"
    test_file = project_root / "tests" / f"test_{module_name}_workflow.py"
    client_file = project_root / "client" / f"run_{module_name}.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(workflow_file, force)
    check_file_exists(test_file, force)
    check_file_exists(client_file, force)

    # Prepare context
    context = {
        "project_name": project_name,
        "workflow_name": class_name,
        "name": class_name,  # For template compatibility
        "module_name": module_name,
        "input_type": input_type,
        "output_type": output_type,
        "input_fields": [],  # Empty list for now, user can customize
        "output_fields": [],  # Empty list for now, user can customize
    }

    # Generate workflow file
    workflow_content = render_template("workflow.py.j2", context)
    write_file(workflow_file, workflow_content)

    # Generate test file
    test_content = render_template("test_workflow.py.j2", context)
    write_file(test_file, test_content)

    # Generate client file
    client_content = render_template("client_run_workflow.py.j2", context)
    write_file(client_file, client_content)

    # Update service.py
    update_service_file(service_file, "workflow", module_name, class_name)

    return {
        "workflow": workflow_file,
        "test": test_file,
        "client": client_file,
    }


def generate_function(
    name: str,
    force: bool = False,
) -> dict[str, Path]:
    """Generate a function with test file.

    Args:
        name: Function name (should be in snake_case)
        force: If True, overwrite existing generated files

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid function name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert to snake_case if needed
    function_name = to_snake_case(name) if any(c.isupper() for c in name) else name

    # Define file paths
    function_file = project_root / "src" / project_name / "functions" / f"{function_name}.py"
    test_file = project_root / "tests" / f"test_{function_name}_function.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(function_file, force)
    check_file_exists(test_file, force)

    # Prepare context
    context = {
        "project_name": project_name,
        "function_name": function_name,
    }

    # Generate function file
    function_content = render_template("function.py.j2", context)
    write_file(function_file, function_content)

    # Generate test file
    test_content = render_template("test_function.py.j2", context)
    write_file(test_file, test_content)

    # Update service.py
    update_service_file(service_file, "function", function_name, function_name)

    return {
        "function": function_file,
        "test": test_file,
    }


def generate_pipeline(
    name: str,
    operators: str,
    force: bool = False,
) -> dict[str, Path]:
    """Generate a pipeline from operator expression.

    Args:
        name: Pipeline name (will be converted to PascalCase for class name)
        operators: Operator expression (e.g., "A → B ⇄ C")
        force: If True, overwrite existing generated files

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid pipeline name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Parse and validate operator expression (import locally to avoid circular import)
    try:
        from restack_gen.parser import parse_and_validate

        ir = parse_and_validate(operators)
    except Exception as e:
        raise GenerationError(f"Failed to parse operator expression: {e}") from e

    # Validate pipeline structure
    try:
        from restack_gen.validator import validate_pipeline

        validation = validate_pipeline(ir, strict=False)
        
        if not validation.is_valid:
            error_details = "\n  - ".join(validation.errors)
            raise GenerationError(f"Pipeline validation failed:\n  - {error_details}")
        
        # Show warnings if any
        if validation.warnings:
            import warnings
            for warning in validation.warnings:
                warnings.warn(warning, UserWarning, stacklevel=2)
                
    except GenerationError:
        raise
    except Exception as e:
        raise GenerationError(f"Failed to validate pipeline: {e}") from e

    # Generate names
    workflow_name = to_snake_case(name)
    pipeline_name = to_pascal_case(workflow_name)
    if not pipeline_name.endswith("Workflow"):
        pipeline_name += "Workflow"

    # Define file paths
    workflow_file = project_root / "src" / project_name / "workflows" / f"{workflow_name}_workflow.py"
    test_file = project_root / "tests" / f"test_{workflow_name}_workflow.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(workflow_file, force)
    check_file_exists(test_file, force)

    # Generate workflow code using codegen
    workflow_content = generate_pipeline_code(ir, pipeline_name, project_name)
    workflow_content = GENERATED_MARKER + "\n" + workflow_content

    # Write workflow file
    write_file(workflow_file, workflow_content)

    # Generate test file
    context = {
        "project_name": project_name,
        "workflow_name": workflow_name,
        "class_name": pipeline_name,
    }
    test_content = render_template("test_workflow.py.j2", context)
    write_file(test_file, test_content)

    # Update service.py
    update_service_file(
        service_file,
        "workflow",
        f"{workflow_name}_workflow",
        pipeline_name,
    )

    return {
        "workflow": workflow_file,
        "test": test_file,
    }
