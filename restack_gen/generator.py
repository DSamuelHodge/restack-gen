"""Resource generation utilities for agents, workflows, and functions."""

import re
from pathlib import Path
from typing import Any

from restack_gen.ast_service import update_service_file
from restack_gen.codegen import generate_pipeline_code
from restack_gen.renderer import render_template


class GenerationError(Exception):
    """Raised when resource generation fails."""


GENERATED_MARKER = "# @generated by restack-gen"


def to_snake_case(name: str) -> str:
    """Convert PascalCase or camelCase to snake_case.

    Args:
        name: Input name

    Returns:
        snake_case version
    """
    # Insert underscore before uppercase letters
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    # Insert underscore before uppercase letters preceded by lowercase
    s2 = re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1)
    return s2.lower()


def to_pascal_case(name: str) -> str:
    """Convert snake_case to PascalCase.

    Args:
        name: Input name in snake_case

    Returns:
        PascalCase version
    """
    parts = name.split("_")
    return "".join(word.capitalize() for word in parts)


def validate_name(name: str) -> tuple[bool, str | None]:
    """Validate resource name.

    Args:
        name: Resource name to validate

    Returns:
        Tuple of (is_valid, error_message)
    """
    if not name:
        return False, "Name cannot be empty"

    # Check for valid identifier characters
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_]*$", name):
        return (
            False,
            "Name must start with letter/underscore and contain only alphanumeric characters and underscores",
        )

    return True, None


def find_project_root() -> Path | None:
    """Find the project root by looking for pyproject.toml.

    Returns:
        Path to project root, or None if not found
    """
    current = Path.cwd()
    for parent in [current] + list(current.parents):
        if (parent / "pyproject.toml").exists():
            return parent
    return None


def get_project_name(project_root: Path) -> str:
    """Extract project name from pyproject.toml.

    Args:
        project_root: Path to project root

    Returns:
        Project name

    Raises:
        GenerationError: If project name cannot be determined
    """
    pyproject = project_root / "pyproject.toml"
    if not pyproject.exists():
        raise GenerationError("pyproject.toml not found")

    with open(pyproject, encoding="utf-8") as f:
        for line in f:
            if line.strip().startswith("name = "):
                # Extract name from 'name = "myproject"'
                name = line.split("=")[1].strip().strip('"').strip("'")
                return name

    raise GenerationError("Could not find project name in pyproject.toml")


def check_file_exists(file_path: Path, force: bool = False) -> None:
    """Check if file exists and handle according to force flag.

    Args:
        file_path: Path to check
        force: If True, allow overwriting

    Raises:
        GenerationError: If file exists and cannot be overwritten
    """
    if not file_path.exists():
        return

    # Check if file has generated marker
    with open(file_path, encoding="utf-8") as f:
        first_line = f.readline()

    if GENERATED_MARKER in first_line:
        if not force:
            raise GenerationError(
                f"File {file_path} already exists (generated). Use --force to overwrite."
            )
    else:
        raise GenerationError(
            f"File {file_path} exists but was not generated by restack-gen. "
            "Will not overwrite to preserve manual changes."
        )


def write_file(file_path: Path, content: str) -> None:
    """Write content to file, creating directories if needed.

    Args:
        file_path: Path to write to
        content: Content to write
    """
    file_path.parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(content)


def _read_yaml(file_path: Path) -> dict[str, Any]:
    """Read a YAML file into a dict, returning empty dict if missing.

    Args:
        file_path: YAML file path

    Returns:
        Dict parsed from YAML or empty dict if file doesn't exist
    """
    import yaml

    if not file_path.exists():
        return {}
    with open(file_path, encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def _write_yaml(file_path: Path, data: dict[str, Any]) -> None:
    """Write a dict to YAML file with safe formatting."""
    import re

    import yaml

    # Use a custom dumper that quotes only semver-like strings and prompt file paths
    class SemverQuotedDumper(yaml.SafeDumper):
        pass

    def _conditional_str_representer(
        dumper: SemverQuotedDumper, value: str
    ) -> "yaml.nodes.Node":  # types from PyYAML
        if re.match(r"^\d+\.\d+\.\d+$", value) or value.startswith("prompts/"):
            return dumper.represent_scalar("tag:yaml.org,2002:str", value, style='"')
        return dumper.represent_scalar("tag:yaml.org,2002:str", value)

    SemverQuotedDumper.add_representer(str, _conditional_str_representer)

    file_path.parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, "w", encoding="utf-8") as f:
        yaml.dump(data, f, sort_keys=False, Dumper=SemverQuotedDumper)


def generate_agent(
    name: str,
    force: bool = False,
    event_type: str = "dict",
    state_type: str = "dict",
    with_llm: bool = False,
    tools_server: str | None = None,
) -> dict[str, Path]:
    """Generate an agent with test and client files.

    Args:
        name: Agent name (will be converted to PascalCase for class name)
        force: If True, overwrite existing generated files
        event_type: Type for agent events
        state_type: Type for agent state
        with_llm: If True, include LLM router and prompt loader
        tools_server: FastMCP tool server name to integrate

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid agent name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert name formats - ensure PascalCase
    if "_" in name:
        # snake_case input
        class_name = to_pascal_case(name) + "Agent"
        module_name = name
    else:
        # Assume PascalCase input
        class_name = name if name.endswith("Agent") else name + "Agent"
        # Ensure first letter is uppercase for PascalCase
        class_name = class_name[0].upper() + class_name[1:]
        # Extract base name without "Agent" suffix for module
        base_name = class_name.replace("Agent", "")
        module_name = to_snake_case(base_name)

    # Define file paths
    agent_file = project_root / "src" / project_name / "agents" / f"{module_name}.py"
    test_file = project_root / "tests" / f"test_{module_name}_agent.py"
    client_file = project_root / "client" / f"schedule_{module_name}.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(agent_file, force)
    check_file_exists(test_file, force)
    check_file_exists(client_file, force)

    # Prepare context
    context = {
        "project_name": project_name,
        "agent_name": class_name,
        "name": class_name,  # For template compatibility
        "event_enum_name": f"{class_name}Event",
        "module_name": module_name,
        "event_type": event_type,
        "state_type": state_type,
        "events": [],  # Empty list for now, user can add events
        "state_fields": [],  # Empty list for now, user can add state fields
        "with_llm": with_llm,
        "tools_server": tools_server,
    }

    # Generate agent file
    agent_content = render_template("agent.py.j2", context)
    write_file(agent_file, agent_content)

    # Generate test file
    test_content = render_template("test_agent.py.j2", context)
    write_file(test_file, test_content)

    # Generate client file
    client_content = render_template("client_schedule_agent.py.j2", context)
    write_file(client_file, client_content)

    # Update service.py
    update_service_file(service_file, "agent", module_name, class_name)

    return {
        "agent": agent_file,
        "test": test_file,
        "client": client_file,
    }


def generate_workflow(
    name: str,
    force: bool = False,
    input_type: str = "dict",
    output_type: str = "dict",
) -> dict[str, Path]:
    """Generate a workflow with test and client files.

    Args:
        name: Workflow name (will be converted to PascalCase for class name)
        force: If True, overwrite existing generated files
        input_type: Type for workflow input
        output_type: Type for workflow output

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid workflow name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert name formats - ensure PascalCase
    if "_" in name:
        # snake_case input
        class_name = to_pascal_case(name) + "Workflow"
        module_name = name
    else:
        # Assume PascalCase input
        class_name = name if name.endswith("Workflow") else name + "Workflow"
        # Ensure first letter is uppercase for PascalCase
        class_name = class_name[0].upper() + class_name[1:]
        # Extract base name without "Workflow" suffix for module
        base_name = class_name.replace("Workflow", "")
        module_name = to_snake_case(base_name)

    # Define file paths
    workflow_file = project_root / "src" / project_name / "workflows" / f"{module_name}.py"
    test_file = project_root / "tests" / f"test_{module_name}_workflow.py"
    client_file = project_root / "client" / f"run_{module_name}.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(workflow_file, force)
    check_file_exists(test_file, force)
    check_file_exists(client_file, force)

    # Prepare context
    context = {
        "project_name": project_name,
        "workflow_name": class_name,
        "name": class_name,  # For template compatibility
        "module_name": module_name,
        "input_type": input_type,
        "output_type": output_type,
        "input_fields": [],  # Empty list for now, user can customize
        "output_fields": [],  # Empty list for now, user can customize
    }

    # Generate workflow file
    workflow_content = render_template("workflow.py.j2", context)
    write_file(workflow_file, workflow_content)

    # Generate test file
    test_content = render_template("test_workflow.py.j2", context)
    write_file(test_file, test_content)

    # Generate client file
    client_content = render_template("client_run_workflow.py.j2", context)
    write_file(client_file, client_content)

    # Update service.py
    update_service_file(service_file, "workflow", module_name, class_name)

    return {
        "workflow": workflow_file,
        "test": test_file,
        "client": client_file,
    }


def generate_function(
    name: str,
    force: bool = False,
) -> dict[str, Path]:
    """Generate a function with test file.

    Args:
        name: Function name (should be in snake_case)
        force: If True, overwrite existing generated files

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid function name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert to snake_case if needed
    function_name = to_snake_case(name) if any(c.isupper() for c in name) else name

    # Define file paths
    function_file = project_root / "src" / project_name / "functions" / f"{function_name}.py"
    test_file = project_root / "tests" / f"test_{function_name}_function.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(function_file, force)
    check_file_exists(test_file, force)

    # Prepare context
    context = {
        "project_name": project_name,
        "function_name": function_name,
    }

    # Generate function file
    function_content = render_template("function.py.j2", context)
    write_file(function_file, function_content)

    # Generate test file
    test_content = render_template("test_function.py.j2", context)
    write_file(test_file, test_content)

    # Update service.py
    update_service_file(service_file, "function", function_name, function_name)

    return {
        "function": function_file,
        "test": test_file,
    }


def generate_pipeline(
    name: str,
    operators: str,
    force: bool = False,
) -> dict[str, Path]:
    """Generate a pipeline from operator expression.

    Args:
        name: Pipeline name (will be converted to PascalCase for class name)
        operators: Operator expression (e.g., "A → B ⇄ C")
        force: If True, overwrite existing generated files

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid pipeline name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Parse and validate operator expression (import locally to avoid circular import)
    try:
        from restack_gen.parser import parse_and_validate

        ir = parse_and_validate(operators)
    except Exception as e:
        raise GenerationError(f"Failed to parse operator expression: {e}") from e

    # Validate pipeline structure
    try:
        from restack_gen.validator import validate_pipeline

        validation = validate_pipeline(ir, strict=False)

        if not validation.is_valid:
            error_details = "\n  - ".join(validation.errors)
            raise GenerationError(f"Pipeline validation failed:\n  - {error_details}")

        # Show warnings if any
        if validation.warnings:
            import warnings

            for warning in validation.warnings:
                warnings.warn(warning, UserWarning, stacklevel=2)

    except GenerationError:
        raise
    except Exception as e:
        raise GenerationError(f"Failed to validate pipeline: {e}") from e

    # Generate names
    workflow_name = to_snake_case(name)
    pipeline_name = to_pascal_case(workflow_name)
    if not pipeline_name.endswith("Workflow"):
        pipeline_name += "Workflow"

    # Define file paths
    workflow_file = (
        project_root / "src" / project_name / "workflows" / f"{workflow_name}_workflow.py"
    )
    test_file = project_root / "tests" / f"test_{workflow_name}_workflow.py"
    service_file = project_root / "server" / "service.py"

    # Check if files exist
    check_file_exists(workflow_file, force)
    check_file_exists(test_file, force)

    # Generate workflow code using codegen
    workflow_content = generate_pipeline_code(ir, pipeline_name, project_name)
    workflow_content = GENERATED_MARKER + "\n" + workflow_content

    # Write workflow file
    write_file(workflow_file, workflow_content)

    # Generate test file
    context = {
        "project_name": project_name,
        "workflow_name": workflow_name,
        "class_name": pipeline_name,
    }
    test_content = render_template("test_workflow.py.j2", context)
    write_file(test_file, test_content)

    # Update service.py
    update_service_file(
        service_file,
        "workflow",
        f"{workflow_name}_workflow",
        pipeline_name,
    )

    return {
        "workflow": workflow_file,
        "test": test_file,
    }


def generate_llm_config(
    force: bool = False,
    backend: str = "direct",
) -> dict[str, Path]:
    """Generate LLM router configuration files.

    Args:
        force: If True, overwrite existing files
        backend: Backend type ("direct" or "kong")

    Returns:
        Dictionary mapping file type to path

    Raises:
        GenerationError: If generation fails
    """
    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Define file paths
    config_dir = project_root / "config"
    config_file = config_dir / "llm_router.yaml"
    common_dir = project_root / "src" / project_name / "common"
    llm_router_file = common_dir / "llm_router.py"

    # Check if files exist
    if config_file.exists() and not force:
        raise GenerationError(
            f"Config file {config_file} already exists. Use --force to overwrite."
        )

    if llm_router_file.exists() and not force:
        raise GenerationError(f"File {llm_router_file} already exists. Use --force to overwrite.")

    # Prepare context
    context = {
        "backend": backend,
    }

    # Generate config file
    config_content = render_template("llm_router.yaml.j2", context)
    write_file(config_file, config_content)

    # Generate LLM router module
    router_content = render_template("llm_router.py.j2", context)
    write_file(llm_router_file, router_content)

    # Create __init__.py in common if it doesn't exist
    init_file = common_dir / "__init__.py"
    if not init_file.exists():
        write_file(init_file, '"""Common utilities and shared components."""\n')

    return {
        "config": config_file,
        "router": llm_router_file,
    }


def generate_prompt(
    name: str,
    version: str = "1.0.0",
    force: bool = False,
) -> dict[str, Path]:
    """Generate a versioned prompt markdown file and update the prompt registry.

    Creates/updates config/prompts.yaml and ensures a prompt loader exists.

    Args:
        name: Prompt name (PascalCase or snake_case). Stored as snake_case key.
        version: Semantic version (e.g., 1.0.0). Determines file path.
        force: Overwrite existing prompt version file if set.

    Returns:
        Dict with paths: {'prompt', 'config', 'loader' (optional)}
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid prompt name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Normalize key and file locations
    prompt_key = to_snake_case(name)
    config_file = project_root / "config" / "prompts.yaml"
    prompt_dir = project_root / "prompts" / prompt_key
    prompt_file = prompt_dir / f"v{version}.md"
    common_dir = project_root / "src" / project_name / "common"
    loader_file = common_dir / "prompt_loader.py"

    # Check overwrite policy for prompt file
    if prompt_file.exists() and not force:
        # Even though prompt files are user-editable, we guard accidental overwrite
        raise GenerationError(
            f"Prompt version file {prompt_file} already exists. Use --force to overwrite."
        )

    # Ensure prompt loader exists (generate if missing)
    loader_generated = False
    if not loader_file.exists():
        import datetime as _dt
        from importlib.metadata import version as _pkg_version

        try:
            gen_version = _pkg_version("restack-gen")
        except Exception:
            gen_version = "unknown"

        loader_content = render_template(
            "prompt_loader.py.j2",
            {
                "version": gen_version,
                "timestamp": _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            },
        )
        write_file(loader_file, loader_content)
        # create __init__ in common if absent
        init_file = common_dir / "__init__.py"
        if not init_file.exists():
            write_file(init_file, '"""Common utilities and shared components."""\n')
        loader_generated = True

    # Render prompt markdown from template
    prompt_md = render_template(
        "prompt_template.md.j2",
        {
            "version": version,
            "model": "gpt-4o-mini",
            "temperature": 0.7,
            "max_tokens": 4096,
            "name": prompt_key,
        },
    )
    write_file(prompt_file, prompt_md)

    # Update registry YAML
    registry = _read_yaml(config_file)
    if "prompts" not in registry:
        registry["prompts"] = {}
    entry = registry["prompts"].get(prompt_key) or {
        "description": f"Prompt for {prompt_key.replace('_', ' ')}",
        "versions": {},
        "latest": version,
        "resolution": "semver",
    }
    # Add/overwrite mapping for version to file path
    rel_path = f"prompts/{prompt_key}/v{version}.md"
    entry.setdefault("versions", {})[version] = rel_path

    # Update 'latest' if the incoming version is greater (lexicographic fallback to simple semver compare)
    def _parse(v: str) -> tuple[int, int, int]:
        try:
            major, minor, patch = v.split(".")
            return (int(major), int(minor), int(patch))
        except Exception:
            return (0, 0, 0)

    try:
        if _parse(version) >= _parse(entry.get("latest", "0.0.0")):
            entry["latest"] = version
    except Exception:
        # Best effort; keep existing latest if parsing failed
        pass

    registry["prompts"][prompt_key] = entry
    _write_yaml(config_file, registry)

    result: dict[str, Path] = {
        "prompt": prompt_file,
        "config": config_file,
    }
    if loader_generated:
        result["loader"] = loader_file
    return result


def generate_tool_server(
    name: str,
    force: bool = False,
) -> dict[str, Path]:
    """Generate a FastMCP tool server with configuration.

    Args:
        name: Tool server name (will be converted to PascalCase for class name)
        force: If True, overwrite existing generated files

    Returns:
        Dictionary mapping file type to path ('config', 'server')

    Raises:
        GenerationError: If generation fails
    """
    # Validate name
    is_valid, error = validate_name(name)
    if not is_valid:
        raise GenerationError(f"Invalid tool server name: {error}")

    # Find project root
    project_root = find_project_root()
    if not project_root:
        raise GenerationError(
            "Not in a restack-gen project. Run this command from within a project directory."
        )

    project_name = get_project_name(project_root)

    # Convert name formats
    if "_" in name:
        # snake_case input
        class_name = to_pascal_case(name)
        module_name = name
    else:
        # Assume PascalCase input
        class_name = name
        module_name = to_snake_case(name)

    # Generate server name (lowercase, underscores)
    server_name = f"{module_name}_tools"

    # Define file paths
    config_dir = project_root / "config"
    config_file = config_dir / "tools.yaml"
    tools_dir = project_root / "src" / project_name / "tools"
    server_file = tools_dir / f"{module_name}_mcp.py"
    tools_init = tools_dir / "__init__.py"
    common_dir = project_root / "src" / project_name / "common"
    manager_file = common_dir / "fastmcp_manager.py"

    # Check if files exist
    if server_file.exists() and not force:
        raise GenerationError(
            f"Tool server {server_file} already exists. Use --force to overwrite."
        )

    # Prepare context
    import datetime

    context = {
        "name": class_name,
        "project_name": project_name,
        "module_name": module_name,
        "module_file_name": f"{module_name}_mcp",  # For import paths in config
        "server_name": server_name,
        "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }

    # Generate tool server file
    server_content = render_template("tool_server.py.j2", context)
    write_file(server_file, server_content)

    # Generate or update config file
    if config_file.exists() and not force:
        # Config exists, don't overwrite
        print(f"Config file {config_file} already exists. Skipping config generation.")
        print("Add this server manually to your tools.yaml configuration.")
    else:
        config_content = render_template("tools.yaml.j2", context)
        write_file(config_file, config_content)

    # Create __init__.py in tools directory if it doesn't exist
    if not tools_init.exists():
        write_file(tools_init, '"""FastMCP tool servers for agent capabilities."""\n')

    # Generate FastMCP manager if this is the first tool server
    manager_generated = False
    if not manager_file.exists():
        try:
            from importlib.metadata import version

            gen_version = version("restack-gen")
        except Exception:
            gen_version = "unknown"

        manager_context = {
            "version": gen_version,
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }
        manager_content = render_template("fastmcp_manager.py.j2", manager_context)
        write_file(manager_file, manager_content)
        print(f"Generated FastMCP manager: {manager_file}")
        manager_generated = True

    result: dict[str, Path] = {
        "server": server_file,
    }
    # Only include keys when a file was generated/overwritten to keep values as Path (not None)
    if not config_file.exists() or force:
        result["config"] = config_file
    if manager_generated:
        result["manager"] = manager_file
    return result
