# @generated by restack-gen
"""Prompt Loader with semantic version resolution.

Loads prompt templates from config/prompts.yaml and supports exact or semver resolution.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Dict, Any

import yaml


@dataclass
class PromptTemplate:
    content: str
    metadata: Dict[str, Any]
    version: str

    def format(self, **kwargs: Any) -> str:
        return self.content.format(**kwargs)


class PromptLoader:
    def __init__(self, config_path: str = "config/prompts.yaml") -> None:
        self.config_path = Path(config_path)
        self.config = self._load_config(self.config_path)
        self.cache: Dict[str, PromptTemplate] = {}
        self._mtimes: Dict[str, float] = {}

    async def load(self, name: str, version: Optional[str] = None) -> PromptTemplate:
        """Load a prompt by name and optional semver-compatible version.

        If version is None, use the 'latest' configured for the prompt.
        If resolution == 'exact', the requested version must exist.
        If resolution == 'semver', the requested prefix (e.g., '1' or '1.2') resolves
        to the highest available version with that prefix; full '1.2.3' resolves exactly.
        """
        prompts = self.config.get("prompts", {})
        if name not in prompts:
            raise ValueError(f"Prompt '{name}' not found in registry")

        prompt_cfg = prompts[name]
        resolved_version = self._resolve_version(prompt_cfg, version)
        cache_key = f"{name}:{resolved_version}"

        if cache_key in self.cache:
            # If underlying file changed on disk, invalidate cache entry
            versions: Dict[str, str] = prompt_cfg.get("versions", {})
            file_path = versions.get(resolved_version)
            if file_path:
                p = Path(file_path)
                try:
                    mtime = p.stat().st_mtime
                    if self._mtimes.get(cache_key) == mtime:
                        return self.cache[cache_key]
                except FileNotFoundError:
                    # fall through to raise in _load_file
                    pass

        versions: Dict[str, str] = prompt_cfg.get("versions", {})
        file_path = versions.get(resolved_version)
        if not file_path:
            raise ValueError(f"Version '{resolved_version}' for prompt '{name}' not mapped to a file")

        template = self._load_file(file_path)
        # Track file mtime for invalidation
        try:
            self._mtimes[cache_key] = Path(file_path).stat().st_mtime
        except FileNotFoundError:
            self._mtimes.pop(cache_key, None)
        self.cache[cache_key] = template
        return template

    def _load_config(self, path: Path) -> Dict[str, Any]:
        if not path.exists():
            return {}
        with open(path, encoding="utf-8") as f:
            return yaml.safe_load(f) or {}

    def _load_file(self, file_path: str) -> PromptTemplate:
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")

        text = path.read_text(encoding="utf-8")
        # Parse simple frontmatter delimited by '---' lines
        meta: Dict[str, Any] = {}
        content = text
        if text.startswith("---\n"):
            parts = text.split("\n---\n", 1)
            if len(parts) == 2:
                fm = parts[0].removeprefix("---\n")
                content = parts[1]
                try:
                    meta = yaml.safe_load(fm) or {}
                except Exception:
                    meta = {}

        version = str(meta.get("version", "0.0.0"))
        return PromptTemplate(content=content, metadata=meta, version=version)

    def _resolve_version(self, cfg: Dict[str, Any], requested: Optional[str]) -> str:
        if requested is None:
            latest = cfg.get("latest")
            if not latest:
                raise ValueError("No 'latest' configured for prompt")
            return str(latest)

        resolution = str(cfg.get("resolution", "semver")).lower()
        versions = cfg.get("versions", {})

        if resolution == "exact":
            if requested not in versions:
                raise ValueError(f"Version '{requested}' not found (exact resolution)")
            return requested

        # semver-like resolution by prefix matching
        requested_parts = self._parse_version_prefix(requested)
        available = sorted(versions.keys(), key=self._parse_version_full, reverse=True)
        for ver in available:
            if self._prefix_matches(requested_parts, self._parse_version_full(ver)):
                return ver
        raise ValueError(f"No compatible version for '{requested}'")

    def _parse_version_full(self, v: str) -> tuple[int, int, int]:
        try:
            major, minor, patch = v.split(".")
            return (int(major), int(minor), int(patch))
        except Exception:
            return (0, 0, 0)

    def _parse_version_prefix(self, v: str) -> tuple[int, ...]:
        try:
            parts = tuple(int(p) for p in v.split("."))
            return parts
        except Exception:
            return tuple()

    def _prefix_matches(self, req: tuple[int, ...], avail: tuple[int, int, int]) -> bool:
        for i, r in enumerate(req):
            if i >= len(avail) or r != avail[i]:
                return False
        return True
