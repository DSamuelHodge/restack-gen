# @generated by restack-gen v2.0.0
"""
Research FastMCP Tool Server

This server exposes tools via the Model Context Protocol (MCP).
Add your custom tools by decorating functions with @mcp.tool()

Generated: 2025-10-26 00:27:34
"""
import os
import re
from typing import Any

from fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP("research_tools")


@mcp.tool()
async def web_search(query: str, max_results: int = 10) -> dict[str, Any]:
    """
    Search the web using Brave Search API

    Args:
        query: Search query string
        max_results: Maximum number of results to return (default: 10)

    Returns:
        Dict with search results containing:
        - results: List of search result objects
        - query: The original search query
        - count: Number of results returned

    Example:
        results = await web_search("FastMCP Python library")
        for result in results["results"]:
            print(result["title"], result["url"])
    """
    # TODO: Implement web search using Brave Search API
    # Get API key from environment
    api_key = os.getenv("BRAVE_API_KEY")

    if not api_key:
        return {
            "error": "BRAVE_API_KEY not set in environment",
            "results": [],
            "query": query,
            "count": 0,
        }

    # TODO: Make actual API call to Brave Search
    # This is a placeholder implementation
    return {
        "results": [
            {
                "title": f"Sample result for: {query}",
                "url": "https://example.com",
                "description": "Replace this with actual Brave Search API implementation",
            }
        ],
        "query": query,
        "count": 1,
    }


@mcp.tool()
async def extract_urls(text: str) -> list[str]:
    """
    Extract URLs from text using regex pattern matching

    Args:
        text: Text to parse for URLs

    Returns:
        List of extracted URLs (http and https)

    Example:
        urls = await extract_urls("Check out https://example.com and http://test.org")
        # Returns: ["https://example.com", "http://test.org"]
    """

    # URL regex pattern (matches http and https)
    url_pattern = r"https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&/=]*)"

    urls = re.findall(url_pattern, text)
    return urls


@mcp.tool()
async def calculate(expression: str) -> dict[str, Any]:
    """
    Safely evaluate a mathematical expression

    Args:
        expression: Mathematical expression to evaluate (e.g., "2 + 2", "10 * 5")

    Returns:
        Dict with result and original expression:
        - result: The calculated result
        - expression: The original expression
        - error: Error message if evaluation failed

    Example:
        result = await calculate("2 + 2")
        # Returns: {"result": 4.0, "expression": "2 + 2"}
    """
    try:
        # Safe evaluation - only allow basic math operations
        allowed_chars = set("0123456789+-*/(). ")
        if not all(c in allowed_chars for c in expression):
            return {
                "error": "Invalid characters in expression. Only numbers and basic operators allowed.",
                "expression": expression,
                "result": None,
            }

        result = eval(expression, {"__builtins__": {}}, {})
        return {"result": float(result), "expression": expression}
    except Exception as e:
        return {"error": str(e), "expression": expression, "result": None}


class ResearchToolServer:
    """
    FastMCP server class for Research tools

    This class manages the lifecycle of the MCP server.
    Call run() to start the server with the specified transport.
    """

    def __init__(self):
        self.mcp = mcp
        self.name = "research_tools"

    async def run(self, transport: str = "stdio"):
        """
        Start the FastMCP server

        Args:
            transport: Transport protocol to use ("stdio" or "sse")
                - stdio: Standard input/output (for local processes)
                - sse: Server-Sent Events over HTTP (for remote access)
        """
        await self.mcp.run(transport=transport)

    async def health_check(self) -> bool:
        """
        Check if the server is healthy

        Returns:
            True if server is running and responsive
        """
        try:
            # Check if tools are registered
            tools = self.mcp.list_tools()
            return len(tools) > 0
        except Exception:
            return False


# For direct execution
if __name__ == "__main__":
    import asyncio

    server = ResearchToolServer()
    asyncio.run(server.run())
